"""
Graph-based SIRS simulator driven by externally supplied temporal parameters.

This module adapts the teacher-provided message passing idea into a pure
forward simulator: for a fixed tree network (nodes + edges), and for a given
sequence of yearly parameters β(t), γ(t), ω(t), it rolls the SIRS dynamics
forward using Euler-style updates and returns aggregated park-level totals.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Tuple

import torch
import torch.nn as nn


@dataclass
class GraphSIRSOutput:
    """
    Container for aggregated and node-level trajectories produced by the
    message-passing simulator.
    """

    S: torch.Tensor  # [T] aggregated susceptible counts (includes initial state)
    I: torch.Tensor  # [T]
    R: torch.Tensor  # [T] current recovered counts
    C: torch.Tensor  # [T] cumulative recoveries (monotone)
    new_recoveries: torch.Tensor  # [T-1] yearly recoveries
    node_S: torch.Tensor  # [N] final node-level susceptible mass
    node_I: torch.Tensor  # [N]
    node_R: torch.Tensor  # [N]
    node_C: torch.Tensor  # [N] cumulative recoveries per node


class GraphSIRSMessagePassing(nn.Module):
    """
    Lightweight message-passing SIRS simulator.

    Compared with the teacher's original MessagePassing subclass, this module
    removes learnable β/γ/ω parameters. Instead, forward() receives the yearly
    parameter sequences (generated by the RNN+VI macro model) and simply
    applies them over the graph using a distance-decayed infection pressure.
    """

    def __init__(
        self,
        edge_index: torch.LongTensor,
        edge_distance: Optional[torch.Tensor],
        num_nodes: int,
        *,
        monthly_steps: int = 12,
        sirs: bool = True,
        L_init: float = 120.0,
        node_weights: Optional[torch.Tensor] = None,
    ) -> None:
        super().__init__()
        if edge_index.dim() != 2 or edge_index.size(0) != 2:
            raise ValueError("edge_index must have shape [2, E]")
        self.register_buffer("edge_index", edge_index.clone())

        if edge_distance is None:
            edge_distance = torch.ones(edge_index.size(1), dtype=torch.float32)
        self.register_buffer("edge_distance", edge_distance.float().clone())

        self.num_nodes = int(num_nodes)
        self.monthly_steps = int(monthly_steps)
        self.sirs = bool(sirs)

        if node_weights is None:
            node_weights = torch.ones(num_nodes, dtype=torch.float32)
        self.register_buffer("node_weights", node_weights.float().reshape(-1))

        self.log_L = nn.Parameter(torch.log(torch.tensor(float(L_init))))

    @property
    def L(self) -> torch.Tensor:
        return torch.exp(self.log_L).clamp_min(1e-3)

    def _infection_pressure(self, I: torch.Tensor) -> torch.Tensor:
        """
        Aggregate infection pressure λ_i = Σ_j I_j * exp(-dist_ij / L).
        """
        src, dst = self.edge_index
        weight = torch.exp(-self.edge_distance / self.L)
        contrib = I[src] * weight
        lam = torch.zeros_like(I)
        lam.index_add_(0, dst, contrib)
        return lam

    def forward(
        self,
        beta_seq: torch.Tensor,
        gamma_seq: torch.Tensor,
        omega_seq: Optional[torch.Tensor],
        initial_state: Tuple[torch.Tensor, torch.Tensor, torch.Tensor, Optional[torch.Tensor]],
    ) -> GraphSIRSOutput:
        """
        Run the simulator for len(beta_seq) yearly steps.

        Parameters
        ----------
        beta_seq, gamma_seq, omega_seq:
            1-D tensors of length T-1 containing macro parameters for each
            yearly interval (beta >= 0, gamma >= 0, omega >= 0).
        initial_state:
            Tuple (S0, I0, R0, C0_opt) of node-level states. Each of S0/I0/R0
            is shaped [num_nodes]. C0_opt (if provided) tracks cumulative
            recoveries per node at the starting year; otherwise it defaults
            to R0 (meaning every currently recovered node has experienced one
            recovery event already).
        """

        beta_seq = beta_seq.reshape(-1)
        gamma_seq = gamma_seq.reshape(-1)
        if omega_seq is None:
            omega_seq = torch.zeros_like(beta_seq)
        else:
            omega_seq = omega_seq.reshape(-1)

        if beta_seq.numel() != gamma_seq.numel() or beta_seq.numel() != omega_seq.numel():
            raise ValueError("beta_seq, gamma_seq, omega_seq must share the same length")

        S_t, I_t, R_t, C_t = initial_state
        if C_t is None:
            C_t = R_t.clone()

        S_t = S_t.clone()
        I_t = I_t.clone()
        R_t = R_t.clone()
        C_t = C_t.clone()

        device = S_t.device
        node_weights = self.node_weights.to(device)

        dt = 1.0 / float(self.monthly_steps)

        S_hist = [torch.sum(S_t * node_weights)]
        I_hist = [torch.sum(I_t * node_weights)]
        R_hist = [torch.sum(R_t * node_weights)]
        C_hist = [torch.sum(C_t * node_weights)]
        yearly_new_recoveries = []

        for beta_raw, gamma_raw, omega_raw in zip(beta_seq, gamma_seq, omega_seq):
            beta = torch.clamp(beta_raw, min=0.0)
            gamma = torch.clamp(gamma_raw, min=0.0)
            omega = torch.clamp(omega_raw, min=0.0) if self.sirs else torch.zeros((), device=device)

            yearly_recov = torch.zeros((), device=device)

            for _ in range(self.monthly_steps):
                lam = self._infection_pressure(I_t)

                # Convert instantaneous rates to event probabilities in dt.
                infection_prob = 1.0 - torch.exp(-beta * lam * dt)
                infection_prob = infection_prob.clamp(0.0, 1.0)
                new_infections = (S_t * infection_prob).clamp_max(S_t)

                recovery_prob = 1.0 - torch.exp(-gamma * dt)
                recovery_prob = recovery_prob.clamp(0.0, 1.0)
                recoveries = (I_t * recovery_prob).clamp_max(I_t)

                if self.sirs:
                    return_prob = 1.0 - torch.exp(-omega * dt)
                    return_prob = return_prob.clamp(0.0, 1.0)
                    returning = (R_t * return_prob).clamp_max(R_t)
                else:
                    returning = torch.zeros_like(R_t)

                S_t = torch.clamp(S_t - new_infections + returning, 0.0, 1.0)
                I_t = torch.clamp(I_t + new_infections - recoveries, 0.0, 1.0)
                R_t = torch.clamp(R_t + recoveries - returning, 0.0, 1.0)

                C_t = C_t + recoveries
                yearly_recov = yearly_recov + torch.sum(recoveries * node_weights)

                # Normalise to guard against numerical drift.
                total = (S_t + I_t + R_t).clamp_min(1e-8)
                S_t = S_t / total
                I_t = I_t / total
                R_t = R_t / total

            S_hist.append(torch.sum(S_t * node_weights))
            I_hist.append(torch.sum(I_t * node_weights))
            R_hist.append(torch.sum(R_t * node_weights))
            C_hist.append(torch.sum(C_t * node_weights))
            yearly_new_recoveries.append(yearly_recov)

        return GraphSIRSOutput(
            S=torch.stack(S_hist),
            I=torch.stack(I_hist),
            R=torch.stack(R_hist),
            C=torch.stack(C_hist),
            new_recoveries=torch.stack(yearly_new_recoveries) if yearly_new_recoveries else torch.zeros(0, device=device),
            node_S=S_t,
            node_I=I_t,
            node_R=R_t,
            node_C=C_t,
        )

